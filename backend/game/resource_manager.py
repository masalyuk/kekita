"""Resource management system for food depletion, competition, and regeneration."""

import random
import math
from typing import Dict, List, Tuple, Optional


class ResourceManager:
    """Manages resource depletion, competition, regeneration, and variety."""
    
    def __init__(self, world):
        """
        Initialize resource manager.
        
        Args:
            world: World instance
        """
        self.world = world
        self.claimed_resources = {}  # {resource_id: creature_id} - who claimed what
        self.resource_regeneration_timers = {}  # {resource_id: turns_until_regeneration}
        self.regeneration_rates = {}  # {region_key: regeneration_rate} - per region
        self._initialize_regeneration_rates()
        
        # Resource types beyond food
        self.resource_types = {
            'food': {'energy': True, 'regenerates': True},
            'water': {'energy': True, 'regenerates': True, 'special': True},
            'shelter': {'energy': False, 'regenerates': False, 'special': True},
        }
    
    def _initialize_regeneration_rates(self):
        """Initialize regeneration rates per region."""
        for region_key, density in self.world.regions.items():
            # Higher density regions regenerate faster
            # Base rate: 10-20 turns, modified by density
            base_rate = 15
            density_modifier = density  # 0.3 to 1.5
            regeneration_rate = int(base_rate / density_modifier)
            self.regeneration_rates[region_key] = max(5, min(30, regeneration_rate))
    
    def get_regeneration_rate(self, x, y):
        """
        Get regeneration rate for a position.
        
        Args:
            x: X coordinate
            y: Y coordinate
            
        Returns:
            Turns until regeneration
        """
        region_x = x // self.world.region_size
        region_y = y // self.world.region_size
        region_key = (region_x, region_y)
        return self.regeneration_rates.get(region_key, 15)
    
    def claim_resource(self, creature_id, resource_id):
        """
        Claim a resource for a creature.
        
        Args:
            creature_id: ID of creature claiming
            resource_id: ID of resource being claimed
            
        Returns:
            True if successfully claimed, False if already claimed
        """
        if resource_id in self.claimed_resources:
            return False  # Already claimed
        
        self.claimed_resources[resource_id] = creature_id
        return True
    
    def release_resource(self, resource_id):
        """
        Release a claimed resource.
        
        Args:
            resource_id: ID of resource to release
        """
        if resource_id in self.claimed_resources:
            del self.claimed_resources[resource_id]
    
    def is_resource_claimed(self, resource_id):
        """
        Check if resource is claimed.
        
        Args:
            resource_id: ID of resource
            
        Returns:
            Creature ID if claimed, None otherwise
        """
        return self.claimed_resources.get(resource_id)
    
    def can_access_resource(self, creature_id, resource_id):
        """
        Check if creature can access a resource.
        
        Args:
            creature_id: ID of creature
            resource_id: ID of resource
            
        Returns:
            True if can access (not claimed or claimed by self)
        """
        claimed_by = self.is_resource_claimed(resource_id)
        return claimed_by is None or claimed_by == creature_id
    
    def process_resource_depletion(self):
        """
        Process resource depletion - food doesn't respawn indefinitely.
        Instead, track regeneration timers.
        """
        # Update regeneration timers
        resources_to_regenerate = []
        for resource_id, turns_remaining in list(self.resource_regeneration_timers.items()):
            self.resource_regeneration_timers[resource_id] = turns_remaining - 1
            if self.resource_regeneration_timers[resource_id] <= 0:
                resources_to_regenerate.append(resource_id)
        
        # Regenerate resources that are ready
        for resource_id in resources_to_regenerate:
            del self.resource_regeneration_timers[resource_id]
            # Resource will be regenerated by world spawn logic
    
    def mark_resource_consumed(self, resource_id, x, y):
        """
        Mark a resource as consumed and set regeneration timer.
        
        Args:
            resource_id: ID of consumed resource
            x: X coordinate
            y: Y coordinate
        """
        regeneration_rate = self.get_regeneration_rate(x, y)
        self.resource_regeneration_timers[resource_id] = regeneration_rate
        
        # Release claim if any
        self.release_resource(resource_id)
    
    def should_respawn_food(self, current_food_count):
        """
        Determine if food should respawn based on depletion system.
        
        Args:
            current_food_count: Current number of food items
            
        Returns:
            Tuple of (should_respawn, amount_to_spawn)
        """
        # Only respawn if food count is very low AND regeneration timers allow
        min_food_threshold = 10
        
        if current_food_count < min_food_threshold:
            # Check how many resources are ready to regenerate
            ready_to_regenerate = sum(1 for turns in self.resource_regeneration_timers.values() if turns <= 0)
            
            # Spawn amount based on ready resources and density
            spawn_amount = min(5, ready_to_regenerate + 2)
            return True, spawn_amount
        
        return False, 0
    
    def get_resource_rich_areas(self, creature, radius=5):
        """
        Find areas with more resources for migration.
        
        Args:
            creature: Creature object
            radius: Search radius
            
        Returns:
            List of (x, y, resource_count) tuples sorted by resource count
        """
        if hasattr(creature, 'get_position'):
            pos_x, pos_y = creature.get_position()
        else:
            pos_x, pos_y = creature.x, creature.y
        
        # Scan nearby regions for resource density
        region_x = pos_x // self.world.region_size
        region_y = pos_y // self.world.region_size
        
        rich_areas = []
        
        # Check surrounding regions
        for dx in range(-2, 3):
            for dy in range(-2, 3):
                check_region_x = region_x + dx
                check_region_y = region_y + dy
                region_key = (check_region_x, check_region_y)
                
                if region_key in self.world.regions:
                    density = self.world.regions[region_key]
                    
                    # Count food in this region
                    region_start_x = check_region_x * self.world.region_size
                    region_start_y = check_region_y * self.world.region_size
                    region_end_x = min(self.world.width, region_start_x + self.world.region_size)
                    region_end_y = min(self.world.height, region_start_y + self.world.region_size)
                    
                    food_count = sum(1 for f in self.world.food 
                                   if region_start_x <= f['x'] < region_end_x and
                                      region_start_y <= f['y'] < region_end_y)
                    
                    # Calculate center of region
                    center_x = (region_start_x + region_end_x) // 2
                    center_y = (region_start_y + region_end_y) // 2
                    
                    # Score based on density and food count
                    score = density * 10 + food_count
                    rich_areas.append((center_x, center_y, score))
        
        # Sort by score (highest first)
        rich_areas.sort(key=lambda x: x[2], reverse=True)
        return rich_areas[:5]  # Return top 5 areas
    
    def add_special_resources(self, num_water=3, num_shelter=2):
        """
        Add special resource types (water, shelter) to the world.
        
        Args:
            num_water: Number of water sources to add
            num_shelter: Number of shelter locations to add
        """
        # Water sources - provide energy and are safe zones
        for _ in range(num_water):
            x = random.randint(0, self.world.width - 1)
            y = random.randint(0, self.world.height - 1)
            
            # Avoid spawning on existing resources or creatures
            while (any(f['x'] == x and f['y'] == y for f in self.world.food) or
                   any(c.x == x and c.y == y for c in self.world.cells)):
                x = random.randint(0, self.world.width - 1)
                y = random.randint(0, self.world.height - 1)
            
            self.world.food.append({
                'x': x,
                'y': y,
                'id': self.world._resource_id_counter,
                'type': 'water',
                'energy_value': 20,  # Moderate energy
                'special': True,
                'region_density': self.world.get_region_density(x, y)
            })
            self.world._resource_id_counter += 1
        
        # Shelter - provides protection but no energy
        # Store in a separate list or mark in food list
        # For now, we'll add them as special food items with 0 energy
        for _ in range(num_shelter):
            x = random.randint(0, self.world.width - 1)
            y = random.randint(0, self.world.height - 1)
            
            while (any(f['x'] == x and f['y'] == y for f in self.world.food) or
                   any(c.x == x and c.y == y for c in self.world.cells)):
                x = random.randint(0, self.world.width - 1)
                y = random.randint(0, self.world.height - 1)
            
            self.world.food.append({
                'x': x,
                'y': y,
                'id': self.world._resource_id_counter,
                'type': 'shelter',
                'energy_value': 0,  # No energy, but provides protection
                'special': True,
                'region_density': self.world.get_region_density(x, y)
            })
            self.world._resource_id_counter += 1

